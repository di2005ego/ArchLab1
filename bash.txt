#!/bin/bash
# В сценарии обязательно нужно указать, что это сценарий оболочки или сценарий bash. Данная команда запустит скрипт под интерпретатором bash, так как мы указываем где он находится

# Переменные, которым будут переданы значения, введенные в консоли
LOG_DIR=$1 # Путь до папки LOG
BACKUP_DIR=$2 # Путь до папки BACKUP
x=$3 # Пороговое значение заполненности папки
n=$4 # Количество файлов, которое нужно будет заархивировать при заполненности больше x%

if [ "$#" -ne 4 ] # Проверка количества аргументов, введенных в консоли. Если их было меньше, чем 4, то будет сообщение об ошибке
then
    echo "Error: You must provide exactly 4 arguments."
    echo "LOG-folder, BACKUP-folder, x, n"
    exit 1  # Завершение выполнения скрипта с кодом 1 (сообщает об ошибке)
fi
# $# - количество аргументов, -ne - не равно

if [ ! -d $1 ]
then
 echo "The LOG folder does not exist!"
 exit 0
fi
# Если директории LOG не существует, то вывести на экран соответствующее сообщение и завершить выполнение скрипта с кодом 0

if [ ! -d $2 ]
then
 echo "The BACKUP folder does not exist!"
 exit 0
fi
# Если директории BACKUP не существует, то вывести на экран соответствующее сообщение и завершить выполнение скрипта с кодом 0

curr_fullness=$(df --output=pcent $1 | grep -o '[0-9]\+')
echo "At the moment, the LOG folder is $curr_fullness% percent full."

# В переменную curr_fullness передается текущая заполненность директории LOG в процентном значении
# Делается это с помощью команды df с параметром --output=pcent, чтобы выводился только процент использованного дискового пространства для заданного пути
# Также используется команда grep, которая ищет только числовые значения из вывода команды df. Опция -o заставляет grep выводить только совпадения, не всю строку
# После этого на экран выводится сообщение о текущей заполненности папки LOG

number_of_logfiles=$(ls $1 | wc -l) # ls передает в wc все перечисленные папки и файлы, wc (word-count) с аргументом -l (only lines) считает, сколько он получил, и записывает в переменную

echo "There are $number_of_logfiles files in LOG" # Сообщение о том, сколько файлов в папке LOG

null=0 # Константа для удобства

if [ $n -gt $number_of_logfiles ] # Если значение "n" больше, чем файлов в LOG, то мы присваиваем "n" значение количества файлов в папке.
then
 n=$number_of_logfiles
fi

if [ $n -eq $null ]
then
 echo "The value of 'n' == 0 or LOG is empty, archiving is not required."
 exit 0
fi
# Если значение "n" равно нулю, то выводится сообщение о том, что архивация не требуется, и выполнение скрипта завершается с кодом 0

if [ $curr_fullness -gt $x ]
then
 echo "The occupancy is greater than the allowed value."
 echo "Archiving $n files to the BACKUP folder"
 files=$(find $1 -type f -printf '%T+ %p\n' | sort | head -n $n | awk '{print $2}')
 tar cfvz $2/log_backup-$(date '+%Y-%m-%d_%H-%M').tar.gz -P $files
 rm $files
 echo "Archiving is over!"
fi

# Если текущая заполненность папки LOG больше X%, тот на экран выводится сообщение о заполненности больше допущенного значения
# Затем выводится сообщение об архивации N самых старых файлов в папку BACKUP
# Переменная files получает список путей к N самым давно измененным файлам в папке LOG. Делается это с помощью нескольких команд. Во-первых, find, которая благодаря параметрам -type f и -printf '%T+ %p\n' ищет только файлы (не каталоги) и выводит время последнего изменения каждого файла. Во-вторых, командой sort сортируется вывод команды find по времени последнего изменения, а затем передается в команду head, которая, получив значение N, выводит только N строк из отсортированного списка. В свою очередь команда awk обрабатывает вывод head и выводит пути этих N файлов.
# Затем командой tar происходит архивация этих N файлов в архив формата .tar.gz, название которого будет содержать время и дату создания
# Команда rm удаляет эти файлы из папки LOG